/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
*/

import * as THREE from "three";
import { useGLTF, useTexture } from "@react-three/drei";
import { GLTF } from "three-stdlib";
import { useEffect, useMemo, useRef } from "react";
import {
  ASSET_PATH,
  DECK_TEXTURES,
  WHEEL_TEXTURES,
  DeckTextureKey,
  WheelTextureKey,
  PATHS,
} from "./constants";
import { useFrame } from "@react-three/fiber";
import gsap from "gsap";

type SkateboardModelProps = {
  deckVariant?: DeckTextureKey;
  wheelVariant?: WheelTextureKey;
  truckColor?: string;
  boltColor?: string;
  constantWheelSpin?: boolean;
};

type GLTFResult = GLTF & {
  nodes: {
    GripTape: THREE.Mesh;
    Wheel1: THREE.Mesh;
    Wheel2: THREE.Mesh;
    Deck: THREE.Mesh;
    Wheel4: THREE.Mesh;
    Bolts: THREE.Mesh;
    Wheel3: THREE.Mesh;
    Baseplates: THREE.Mesh;
    Truck1: THREE.Mesh;
    Truck2: THREE.Mesh;
  };
};

export function SkateboardModel({
  deckVariant = "clean",
  wheelVariant = "cream",
  truckColor = "#555555",
  boltColor = "#555555",
  constantWheelSpin = false,
}: SkateboardModelProps) {
  const wheelRefs = useRef<THREE.Object3D[]>([]);

  const { nodes } = useGLTF(PATHS.model) as unknown as GLTFResult;

  const gripTapeDiffuse = useTexture(
    `${ASSET_PATH}/griptape-diffuse.webp`,
    (texture) => {
      texture.wrapS = texture.wrapT = THREE.RepeatWrapping;
      texture.repeat.set(9, 9);
    },
  );

  const gripTapeRoughness = useTexture(
    `${ASSET_PATH}/griptape-roughness.webp`,
    (texture) => {
      texture.wrapS = texture.wrapT = THREE.RepeatWrapping;
      texture.repeat.set(9, 9);
      texture.anisotropy = 8;
    },
  );

  const gripTapeMaterial = useMemo(() => {
    return new THREE.MeshStandardMaterial({
      map: gripTapeDiffuse,
      bumpMap: gripTapeRoughness,
      roughnessMap: gripTapeRoughness,
      bumpScale: 3.5,
      roughness: 1.15,
      color: "#555555",
    });
  }, [gripTapeDiffuse, gripTapeRoughness]);

  const boltMaterial = useMemo(() => {
    return new THREE.MeshStandardMaterial({
      color: boltColor,
      metalness: 0.5,
      roughness: 0.3,
    });
  }, [boltColor]);

  const metalNormal = useTexture(
    `${ASSET_PATH}/metal-normal.avif`,
    (texture) => {
      texture.wrapS = texture.wrapT = THREE.RepeatWrapping;
      texture.anisotropy = 8;
      texture.repeat.set(8, 8);
    },
  );

  const truckMaterial = useMemo(() => {
    return new THREE.MeshStandardMaterial({
      color: truckColor,
      normalMap: metalNormal,
      normalScale: new THREE.Vector2(0.3, 0.3),
      metalness: 0.8,
      roughness: 0.25,
    });
  }, [truckColor, metalNormal]);

  const deckTexture = useTexture(DECK_TEXTURES[deckVariant], (texture) => {
    texture.flipY = false;
    texture.colorSpace = THREE.SRGBColorSpace;
  });

  const deckMaterial = useMemo(() => {
    return new THREE.MeshStandardMaterial({
      roughness: 0.1,
      map: deckTexture,
    });
  }, [deckTexture]);

  const wheelTexture = useTexture(WHEEL_TEXTURES[wheelVariant], (texture) => {
    texture.flipY = false;
    texture.colorSpace = THREE.SRGBColorSpace;
  });

  const wheelMaterial = useMemo(() => {
    return new THREE.MeshStandardMaterial({
      roughness: 0.35,
      map: wheelTexture,
    });
  }, [wheelTexture]);

  useFrame(() => {
    if (!wheelRefs.current || !constantWheelSpin) return;

    wheelRefs.current.forEach((wheel) => {
      if (wheel) wheel.rotation.x += 0.2;
    });
  });

  useEffect(() => {
    if (!wheelRefs.current || constantWheelSpin) return;

    wheelRefs.current.forEach((wheel) => {
      gsap.to(wheel.rotation, {
        x: "+=30",
        duration: 2.5,
        ease: "circ.out",
      });
    });
  }, [constantWheelSpin, wheelVariant]);

  return (
    <group dispose={null}>
      <group name="Scene">
        <mesh
          name="GripTape"
          castShadow
          receiveShadow
          geometry={nodes.GripTape.geometry}
          material={gripTapeMaterial}
          position={[0, 0.286, -0.002]}
        />
        <mesh
          name="Deck"
          castShadow
          receiveShadow
          geometry={nodes.Deck.geometry}
          material={deckMaterial}
          position={[0, 0.271, -0.002]}
        />
        <mesh
          name="Wheel1"
          castShadow
          receiveShadow
          geometry={nodes.Wheel1.geometry}
          material={wheelMaterial}
          position={[0.238, 0.086, 0.635]}
          ref={(el) => (wheelRefs.current[0] = el!)}
        />
        <mesh
          name="Wheel2"
          castShadow
          receiveShadow
          geometry={nodes.Wheel2.geometry}
          material={wheelMaterial}
          position={[-0.237, 0.086, 0.635]}
          ref={(el) => (wheelRefs.current[1] = el!)}
        />
        <mesh
          name="Wheel3"
          castShadow
          receiveShadow
          geometry={nodes.Wheel3.geometry}
          material={wheelMaterial}
          position={[0.237, 0.086, -0.635]}
          rotation={[Math.PI, 0, Math.PI]}
          ref={(el) => (wheelRefs.current[2] = el!)}
        />
        <mesh
          name="Wheel4"
          castShadow
          receiveShadow
          geometry={nodes.Wheel4.geometry}
          material={wheelMaterial}
          position={[-0.238, 0.086, -0.635]}
          rotation={[Math.PI, 0, Math.PI]}
          ref={(el) => (wheelRefs.current[3] = el!)}
        />
        <mesh
          name="Bolts"
          castShadow
          receiveShadow
          geometry={nodes.Bolts.geometry}
          material={boltMaterial}
          position={[0, 0.198, 0]}
          rotation={[Math.PI, 0, Math.PI]}
        />
        <mesh
          name="Baseplates"
          castShadow
          receiveShadow
          geometry={nodes.Baseplates.geometry}
          material={truckMaterial}
          position={[0, 0.211, 0]}
        />
        <mesh
          name="Truck1"
          castShadow
          receiveShadow
          geometry={nodes.Truck1.geometry}
          material={truckMaterial}
          position={[0, 0.101, -0.617]}
        />
        <mesh
          name="Truck2"
          castShadow
          receiveShadow
          geometry={nodes.Truck2.geometry}
          material={truckMaterial}
          position={[0, 0.101, 0.617]}
          rotation={[Math.PI, 0, Math.PI]}
        />
      </group>
    </group>
  );
}

useGLTF.preload(PATHS.model);
